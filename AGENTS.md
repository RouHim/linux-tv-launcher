# Repository Guidelines

## Project Structure & Module Organization
This is a Rust application built with Iced for the UI. Key paths:
- `src/`: application code (entry point in `src/main.rs`, UI in `src/app.rs`, platform helpers in `src/xdg_utils.rs`, storage in `src/storage.rs`).
- `assets/`: static assets embedded at build time (see `src/assets.rs`).
- `target/`: build outputs (generated by Cargo; do not edit).

## Communication Guidelines
- Always address the user as "Mister Anderson".

## Build, Test, and Development Commands
- `cargo run`: build and launch the app in development.
- `cargo build`: compile without running.
- `cargo test`: run unit tests (currently inline module tests in `src/`).
- `cargo fmt`: format code with Rustfmt.
- `cargo clippy`: run lint checks if you have Clippy installed.

## Coding Style & Naming Conventions
- Indentation: 4 spaces (Rust standard).
- Formatting: Rustfmt (`cargo fmt`) is the canonical formatter.
- Naming: Rust conventions (snake_case for functions/modules, PascalCase for types, SCREAMING_SNAKE_CASE for consts).
- Keep modules focused; prefer small, single‑purpose helpers over large functions.

## Testing Guidelines
- Framework: Rust’s built‑in test harness (`#[test]`).
- Location: tests live near the code under `#[cfg(test)]` blocks in `src/`.
- Naming: use descriptive `test_*` function names (examples in `src/model.rs` and `src/storage.rs`).
- Run all tests with `cargo test` before submitting changes.

## Commit & Pull Request Guidelines
- This repository has no commit history yet; use short, imperative commit messages (e.g., “Add launcher persistence”).
- PRs should include: a brief summary, testing notes (commands + results), and screenshots or recordings for UI changes.

## Configuration & Runtime Notes
- Runtime behavior may depend on XDG directories and desktop entries; use valid `.desktop` files when testing launch flows.
- When adding new assets, keep them in `assets/` and reference them via `src/assets.rs`.

## Architecture Documentation
- [Process Monitoring & Focus Management](docs/process_monitoring.md)

### Technical Requirements

- Linux Desktop only
- External crates are allowed, but keep them as low as possible
- Prefer standard Rust libraries and built-in features to minimize external package usage.
- Evaluate trade-offs before adding any third-party crate.
- When using external crates, make sure to use the very latest stable versions.
- All static files needs to be embedded into the binary
- Must compile and run without errors
- Handle user interactions gracefully
- Implement proper error handling and validation
- Use appropriate Rust idioms and patterns
- Logging: prefer `tracing`/`tracing_subscriber` with contextual spans instead of `println!`.
- Error handling: avoid `unwrap`/`expect` in non-test code; surface actionable errors to the UI.
- Structure code into small, focused rust files without using rust modules
- Each file should encapsulate a single responsibility or closely related functionalities.
- Promote reusability and ease of testing by isolating components.
- Follow the SOLID object-oriented design principles to ensure maintainable and extensible code.
- Emphasize single responsibility, open-closed, Liskov substitution, interface segregation, and dependency inversion
  where applicable.
- Use descriptive names and avoid clever tricks or shortcuts that hinder comprehensibility.
- YAGNI - You Aren't Gonna Need It: Avoid adding functionality until it is necessary.
- Don't write unused code for future features.
- Always run code formatters (`cargo fmt`) and linters (`cargo clippy`) when finishing a task.
- Maintain consistent code style across the project to improve readability and reduce friction in reviews.
- Always use RustTLS for any TLS connections, no OpenSSL.
- Use conventional commit messages like "feat: add new feature", "fix: correct a bug", "docs: update documentation", etc.
- Challenge every dead_code warning and remove unused code. If an dead_code is ok, add a comment explaining why.

## Testing Strategy

### Test-Driven Development (TDD)

- Prefer write tests before writing the functionality.
- Use tests to drive design decisions and ensure robust feature implementation.

### Behavior-Driven Development (BDD)

- Write tests in a BDD style, focusing on the expected behavior and outcomes.
- Structure tests to clearly state scenarios, actions, and expected results to improve communication and documentation.

